# Document Project Templates and Output Formats

All output formats, examples, and templates for the document-project skill.

---

## Complete Workflow Output Examples

### Step 0: Configuration and Validation Output

```
‚úÖ Configuration Validated

Codebase Path: src/
Files Found: 487 files
Total Lines: 48,392 lines
Languages Detected:
  - TypeScript: 412 files (85%)
  - JavaScript: 58 files (12%)
  - JSON: 17 files (3%)

Codebase Size: Medium (10K-100K lines) - OPTIMAL for analysis
Existing Docs Mode: merge
Include Tests: Yes
Max Files: 1000 (within limit)

Estimated Analysis Time: 5-7 minutes
Ready to proceed? (yes/no)
```

---

### Step 1: Codebase Analysis Output

```
üîç Analyzing Codebase...

Progress:
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 487/487 files

Analysis Complete:
‚úì Files analyzed: 487
‚úì Lines analyzed: 48,392
‚úì Directories scanned: 42
‚úì Entry points identified: 3
‚úì Dependencies found: 127 (package.json)
‚úì Test files: 89 (18% coverage)

Duration: 4m 23s
```

#### Analysis Summary Object

```json
{
  "files_analyzed": 487,
  "lines_analyzed": 48392,
  "directories": 42,
  "entry_points": [
    "src/index.ts",
    "src/cli.ts",
    "src/server.ts"
  ],
  "dependencies": {
    "total": 127,
    "production": 89,
    "dev": 38
  },
  "languages": [
    {"name": "TypeScript", "files": 412, "percentage": 85},
    {"name": "JavaScript", "files": 58, "percentage": 12},
    {"name": "JSON", "files": 17, "percentage": 3}
  ],
  "test_files": 89,
  "test_coverage_percentage": 18
}
```

---

### Step 2: Pattern Detection Output

```
üîç Detecting Patterns...

Architectural Patterns:
‚úì MVC Pattern (Controllers: 23, Models: 18, Views/Routes: 15)
‚úì Repository Pattern (12 repositories identified)
‚úì Service Layer Pattern (28 services)
‚úì Middleware Pattern (9 middleware functions)

Design Patterns:
‚úì Singleton (5 instances)
‚úì Factory (8 factories)
‚úì Observer (3 event emitters)
‚úì Dependency Injection (widespread, 45 classes)

Naming Conventions:
‚úì Files: kebab-case (98% consistency)
‚úì Classes: PascalCase (100% consistency)
‚úì Functions: camelCase (96% consistency)
‚úì Constants: UPPER_SNAKE_CASE (92% consistency)

Code Organization:
‚úì Feature-based structure (src/features/*)
‚úì Layered architecture (controller/service/repository)
‚úì Shared utilities (src/utils/*)
‚úì Type definitions (src/types/*)

Confidence: 78% (high)
```

#### Pattern Detection Object

```json
{
  "architectural_patterns": [
    {
      "name": "MVC",
      "confidence": 85,
      "evidence": {
        "controllers": 23,
        "models": 18,
        "routes": 15
      }
    },
    {
      "name": "Repository Pattern",
      "confidence": 82,
      "evidence": {
        "repositories": 12,
        "example_files": [
          "src/repositories/UserRepository.ts",
          "src/repositories/OrderRepository.ts"
        ]
      }
    }
  ],
  "design_patterns": [
    {
      "name": "Singleton",
      "instances": 5,
      "confidence": 90,
      "files": ["src/database/connection.ts", "src/config/app.ts"]
    },
    {
      "name": "Factory",
      "instances": 8,
      "confidence": 75,
      "files": ["src/factories/UserFactory.ts"]
    }
  ],
  "naming_conventions": {
    "files": {"style": "kebab-case", "consistency": 98},
    "classes": {"style": "PascalCase", "consistency": 100},
    "functions": {"style": "camelCase", "consistency": 96},
    "constants": {"style": "UPPER_SNAKE_CASE", "consistency": 92}
  },
  "overall_confidence": 78
}
```

---

### Step 3: Generate architecture.md

#### Complete architecture.md Template

```markdown
# Project Architecture

**Auto-generated by BMAD Enhanced**
**Generated:** 2025-10-30
**Confidence:** 78% (review recommended for low-confidence sections marked with ‚ö†Ô∏è)

---

## Overview

**Project Name:** MyApp
**Type:** Node.js/TypeScript Web Application
**Architecture:** MVC with Repository Pattern
**Lines of Code:** 48,392
**Primary Language:** TypeScript (85%)

---

## Technology Stack

### Backend
- **Runtime:** Node.js 20.x
- **Language:** TypeScript 5.3
- **Framework:** Express.js 4.18
- **Database:** PostgreSQL 16 (via pg 8.11)
- **ORM:** Prisma 5.7
- **Authentication:** Passport.js (JWT strategy)
- **Validation:** Zod 3.22

### Frontend
- **Framework:** React 18.2
- **State Management:** Redux Toolkit 2.0
- **Styling:** Tailwind CSS 3.4
- **Build Tool:** Vite 5.0

### Testing
- **Unit Tests:** Jest 29.7
- **E2E Tests:** Playwright 1.40
- **Code Coverage:** 18% (low ‚ö†Ô∏è)

### DevOps
- **Package Manager:** npm
- **Linting:** ESLint 8.56
- **Formatting:** Prettier 3.1
- **CI/CD:** GitHub Actions

---

## Project Structure

```
src/
‚îú‚îÄ‚îÄ controllers/        # HTTP request handlers (23 files)
‚îú‚îÄ‚îÄ services/           # Business logic layer (28 files)
‚îú‚îÄ‚îÄ repositories/       # Data access layer (12 files)
‚îú‚îÄ‚îÄ models/             # Data models and schemas (18 files)
‚îú‚îÄ‚îÄ routes/             # API route definitions (15 files)
‚îú‚îÄ‚îÄ middleware/         # Express middleware (9 files)
‚îú‚îÄ‚îÄ utils/              # Shared utilities (34 files)
‚îú‚îÄ‚îÄ types/              # TypeScript type definitions (22 files)
‚îú‚îÄ‚îÄ config/             # Configuration files (6 files)
‚îú‚îÄ‚îÄ features/           # Feature modules (12 modules)
‚îÇ   ‚îú‚îÄ‚îÄ auth/           # Authentication feature
‚îÇ   ‚îú‚îÄ‚îÄ users/          # User management
‚îÇ   ‚îî‚îÄ‚îÄ orders/         # Order management
‚îî‚îÄ‚îÄ index.ts            # Application entry point
```

**Confidence:** 92% (structure is clear and consistent)

---

## Entry Points

1. **src/index.ts** - Main application server (Express app initialization)
2. **src/cli.ts** - CLI tool entry point (database migrations, seeding)
3. **src/server.ts** - HTTP server setup (port binding, middleware registration)

**Confidence:** 95% (entry points clearly defined)

---

## Data Models

### User Model
```typescript
interface User {
  id: string;           // UUID
  email: string;        // Unique, validated
  passwordHash: string; // bcrypt hash
  name: string;
  role: 'USER' | 'ADMIN';
  createdAt: Date;
  updatedAt: Date;
}
```
**Source:** src/models/User.ts
**Database Table:** users (Prisma schema)

### Order Model
```typescript
interface Order {
  id: string;
  userId: string;       // Foreign key to User
  status: 'PENDING' | 'CONFIRMED' | 'SHIPPED' | 'DELIVERED';
  total: number;
  items: OrderItem[];
  createdAt: Date;
}
```
**Source:** src/models/Order.ts
**Database Table:** orders (Prisma schema)

**Confidence:** 85% (models well-defined, some fields may be missing ‚ö†Ô∏è)

---

## API Specifications

### Authentication Endpoints
- **POST /api/auth/login** - User login (email + password ‚Üí JWT token)
- **POST /api/auth/register** - User registration
- **POST /api/auth/logout** - User logout
- **GET /api/auth/me** - Get current user (requires JWT)

### User Endpoints
- **GET /api/users** - List all users (admin only)
- **GET /api/users/:id** - Get user by ID
- **PUT /api/users/:id** - Update user
- **DELETE /api/users/:id** - Delete user (admin only)

### Order Endpoints
- **GET /api/orders** - List user's orders
- **POST /api/orders** - Create new order
- **GET /api/orders/:id** - Get order details
- **PUT /api/orders/:id/status** - Update order status (admin)

**Confidence:** 72% (endpoints inferred from routes, request/response schemas incomplete ‚ö†Ô∏è)

---

## Architectural Patterns

### MVC Pattern
- **Controllers:** Handle HTTP requests, validate input, call services
  - Example: UserController.ts (CRUD operations for users)
- **Models:** Define data structures and schemas
  - Example: User.ts, Order.ts
- **Views/Routes:** Define API routes and map to controllers
  - Example: userRoutes.ts

**Confidence:** 85%

### Repository Pattern
- **Repositories:** Abstract database access, use Prisma ORM
  - Example: UserRepository.ts (findById, create, update, delete)
- **Services:** Business logic, call repositories
  - Example: AuthService.ts (login, register, hash passwords)

**Confidence:** 82%

### Layered Architecture
1. **Route Layer:** Define endpoints
2. **Middleware Layer:** Authentication, validation, error handling
3. **Controller Layer:** Request/response handling
4. **Service Layer:** Business logic
5. **Repository Layer:** Data access
6. **Database Layer:** PostgreSQL via Prisma

**Confidence:** 88%

---

## Database Architecture

### PostgreSQL Database
- **ORM:** Prisma (schema-first approach)
- **Migrations:** Prisma Migrate
- **Schema File:** prisma/schema.prisma

### Tables (inferred from models):
- **users** - User accounts
- **orders** - Customer orders
- **order_items** - Order line items
- **sessions** - User sessions (JWT storage ‚ö†Ô∏è - unconfirmed)

**Confidence:** 68% (database schema inferred from code, actual schema may differ ‚ö†Ô∏è)

---

## Security Architecture

### Authentication
- **Strategy:** JWT (JSON Web Tokens)
- **Library:** Passport.js with passport-jwt
- **Token Storage:** HTTP-only cookies (inferred ‚ö†Ô∏è)
- **Password Hashing:** bcrypt (cost factor 12)

### Authorization
- **Role-Based:** USER, ADMIN roles
- **Middleware:** authMiddleware.ts checks JWT and roles
- **Protected Routes:** Admin-only routes verified

### Input Validation
- **Library:** Zod schemas
- **Validation Points:** All API endpoints (controller layer)

**Confidence:** 75% (security implementation inferred, needs review ‚ö†Ô∏è)

---

## Performance Considerations

### Database
- **Connection Pooling:** Prisma connection pool (default settings)
- **Indexes:** Assumed on primary keys, foreign keys (unconfirmed ‚ö†Ô∏è)
- **Query Optimization:** No explicit query optimization detected

### Caching
- **No caching layer detected** ‚ö†Ô∏è (Redis not found in dependencies)

### API Performance
- **Rate Limiting:** Not detected ‚ö†Ô∏è
- **Response Compression:** Not detected ‚ö†Ô∏è

**Confidence:** 45% (low - performance architecture unclear ‚ö†Ô∏è)

---

## Deployment Architecture

### Environment Configuration
- **Environment Variables:** Detected .env file usage
- **Config Management:** src/config/app.ts centralizes config

### Build Process
- **TypeScript Compilation:** tsc via npm build script
- **Output:** dist/ directory

### CI/CD
- **GitHub Actions:** .github/workflows/ci.yml detected
- **Pipeline:** Lint ‚Üí Test ‚Üí Build ‚Üí Deploy (deploy step unclear ‚ö†Ô∏è)

**Confidence:** 62% (deployment details incomplete ‚ö†Ô∏è)

---

## Dependencies

### Production Dependencies (89 total)
**Key Libraries:**
- express (4.18.2)
- typescript (5.3.3)
- prisma (5.7.1)
- passport (0.7.0)
- bcrypt (5.1.1)
- zod (3.22.4)

### Development Dependencies (38 total)
- jest (29.7.0)
- eslint (8.56.0)
- prettier (3.1.1)
- playwright (1.40.1)

**Confidence:** 98% (dependencies clearly defined in package.json)

---

## Review Checklist

**‚ö†Ô∏è Low-Confidence Areas (require human review):**

1. **API Request/Response Schemas** (72% confidence)
   - Verify actual request/response formats
   - Document error response structures

2. **Database Schema** (68% confidence)
   - Review actual Prisma schema file
   - Confirm table names and relationships
   - Verify indexes and constraints

3. **Performance Architecture** (45% confidence)
   - Confirm caching strategy (or lack thereof)
   - Verify rate limiting implementation
   - Review query optimization

4. **Deployment Details** (62% confidence)
   - Document production deployment process
   - Verify environment-specific configurations
   - Confirm hosting platform and infrastructure

5. **Security Implementation** (75% confidence)
   - Review JWT configuration (secret, expiration)
   - Verify HTTPS enforcement
   - Confirm input sanitization completeness

---

*This documentation was auto-generated by analyzing the codebase. Areas marked with ‚ö†Ô∏è have lower confidence and should be reviewed by a human expert.*
```

---

### Step 4: Generate standards.md

#### Complete standards.md Template

```markdown
# Coding Standards and Conventions

**Auto-generated from codebase analysis**
**Generated:** 2025-10-30
**Confidence:** 82%

---

## File Naming Conventions

### Consistency: 98% (excellent)

**Pattern:** kebab-case for files
- ‚úÖ user-controller.ts
- ‚úÖ auth-service.ts
- ‚úÖ order-repository.ts
- ‚ùå UserModel.ts (exception - models use PascalCase)

**Exceptions:**
- Models: PascalCase (User.ts, Order.ts)
- React Components: PascalCase (Button.tsx, Header.tsx)

**Recommendation:** Continue using kebab-case for non-component files

---

## Naming Conventions

### Classes: 100% PascalCase (perfect consistency)
```typescript
class UserController { }
class AuthService { }
class UserRepository { }
```

### Functions: 96% camelCase
```typescript
function getUserById(id: string) { }
async function createOrder(data: OrderData) { }
```

**Exceptions (4%):**
- Some test files use snake_case for descriptive test names

### Constants: 92% UPPER_SNAKE_CASE
```typescript
const MAX_LOGIN_ATTEMPTS = 5;
const JWT_SECRET_KEY = process.env.JWT_SECRET;
const DATABASE_URL = process.env.DATABASE_URL;
```

### Variables: 94% camelCase
```typescript
const userId = req.params.id;
let orderTotal = 0;
const isAuthenticated = true;
```

---

## Code Organization Standards

### Feature-Based Structure (Confidence: 90%)

**Pattern:** Group by feature, not by type
```
src/features/auth/
  ‚îú‚îÄ‚îÄ auth.controller.ts
  ‚îú‚îÄ‚îÄ auth.service.ts
  ‚îú‚îÄ‚îÄ auth.routes.ts
  ‚îî‚îÄ‚îÄ auth.types.ts
```

**Benefits:** Cohesive, easier to maintain, clear boundaries

### Layered Architecture (Confidence: 88%)

**Standard Layer Order:**
1. Route ‚Üí 2. Middleware ‚Üí 3. Controller ‚Üí 4. Service ‚Üí 5. Repository ‚Üí 6. Database

**Example Flow:**
```
POST /api/users
‚Üí userRoutes.ts (route definition)
‚Üí authMiddleware.ts (authentication check)
‚Üí UserController.create() (request handling)
‚Üí UserService.createUser() (business logic)
‚Üí UserRepository.create() (database access)
‚Üí Prisma ORM ‚Üí PostgreSQL
```

---

## TypeScript Standards

### Type Safety: Strong (Confidence: 87%)

**Findings:**
- `strict: true` in tsconfig.json ‚úÖ
- `noImplicitAny: true` ‚úÖ
- `strictNullChecks: true` ‚úÖ

**Type Definition Practices:**
- Interfaces for data models (User, Order, etc.)
- Type aliases for unions (UserRole, OrderStatus)
- Zod schemas for runtime validation

**Example:**
```typescript
// Type definition
interface User {
  id: string;
  email: string;
  role: UserRole;
}

type UserRole = 'USER' | 'ADMIN';

// Zod schema for validation
const userSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});
```

### Import Standards (Confidence: 91%)

**Absolute Imports:** 85% of files
```typescript
import { UserService } from '@/services/UserService';
import { UserRepository } from '@/repositories/UserRepository';
```

**Relative Imports:** 15% of files (short distances)
```typescript
import { validateUser } from './validators';
import { UserType } from '../types';
```

**Recommendation:** Prefer absolute imports for cross-feature imports

---

## Error Handling Standards

### Pattern: Centralized Error Middleware (Confidence: 83%)

**Standard:**
```typescript
// Custom error class
class AppError extends Error {
  statusCode: number;
  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
  }
}

// Usage in services
if (!user) {
  throw new AppError('User not found', 404);
}

// Central error handler middleware
app.use((err, req, res, next) => {
  res.status(err.statusCode || 500).json({
    error: err.message,
  });
});
```

**Consistency:** 78% (some inconsistent error handling in older files ‚ö†Ô∏è)

---

## Testing Standards

### Test Coverage: 18% (low ‚ö†Ô∏è)

**Current Practices:**
- Unit tests for services (UserService.test.ts)
- Integration tests for API endpoints (auth.test.ts)
- E2E tests with Playwright (login.spec.ts)

**Test Naming Convention:**
```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user with valid data', async () => {
      // test
    });

    it('should throw error if email already exists', async () => {
      // test
    });
  });
});
```

**Recommendation:** Increase coverage to 80%+ (currently only 18%)

---

## Code Style Standards

### Formatting: Enforced by Prettier (Confidence: 99%)

**Configuration:** .prettierrc
- **Indentation:** 2 spaces
- **Line Length:** 100 characters
- **Quotes:** Single quotes
- **Semicolons:** Required
- **Trailing Commas:** ES5 style

**Linting:** ESLint with TypeScript rules

**Git Hooks:** Husky + lint-staged (format on commit)

---

## Dependency Management

### Version Pinning: Partial (Confidence: 72%)

**Current Practice:**
- Some dependencies pinned exactly (5.3.3)
- Some use caret (^4.18.0)
- Some use tilde (~2.1.0)

**Recommendation:** Pin production dependencies exactly, use caret for dev dependencies

### Dependency Updates: Manual (no automated updates detected)

**Recommendation:** Add Dependabot or Renovate for automated updates

---

## Git Commit Standards

### Commit Message Format: Inconsistent (Confidence: 55% ‚ö†Ô∏è)

**Observed Patterns:**
1. Conventional Commits (35% of commits):
   - `feat: add user login endpoint`
   - `fix: resolve JWT expiration bug`
   - `docs: update API documentation`

2. Simple Messages (45% of commits):
   - `update user service`
   - `fix bugs`
   - `WIP` (work in progress)

3. No Standard (20% of commits):
   - Random messages

**Recommendation:** Adopt Conventional Commits standard formally

---

## Security Standards

### Password Handling (Confidence: 85%)
- bcrypt hashing (cost factor 12) ‚úÖ
- Passwords never logged ‚úÖ
- Password validation (min 8 chars) ‚úÖ

### JWT Handling (Confidence: 75%)
- JWT secret from environment variable ‚úÖ
- Token expiration set ‚úÖ
- Token storage unclear ‚ö†Ô∏è (cookies vs localStorage)

### Input Validation (Confidence: 88%)
- Zod schemas for all API inputs ‚úÖ
- SQL injection prevention (Prisma parameterized queries) ‚úÖ
- XSS prevention unclear ‚ö†Ô∏è

---

## Documentation Standards

### Code Comments: Minimal (Confidence: 68%)

**Current State:**
- 12% of functions have JSDoc comments
- Complex logic occasionally has inline comments
- No standard comment format

**Recommendation:** Add JSDoc comments for public APIs

**Example (observed good practice):**
```typescript
/**
 * Creates a new user account
 * @param data - User registration data (email, password, name)
 * @returns Created user object (without password hash)
 * @throws AppError if email already exists (400)
 */
async function createUser(data: CreateUserDto): Promise<User> {
  // implementation
}
```

---

## Review Checklist

**‚ö†Ô∏è Areas Needing Standardization:**

1. **Error Handling Consistency** (78%)
   - Standardize error handling in older files
   - Document error response formats

2. **Test Coverage** (18%)
   - Increase coverage to 80%+
   - Add tests for critical paths

3. **Commit Message Format** (55%)
   - Adopt Conventional Commits
   - Add commit message linter

4. **Code Documentation** (68%)
   - Add JSDoc to public APIs
   - Document complex algorithms

5. **Dependency Version Policy** (72%)
   - Define version pinning policy
   - Add automated dependency updates

---

*Standards derived from codebase analysis. Low-confidence areas (‚ö†Ô∏è) should be reviewed and formalized by the team.*
```

---

### Step 5: Generate patterns.md

#### Complete patterns.md Template

```markdown
# Design Patterns and Architectural Patterns

**Auto-generated from pattern detection**
**Generated:** 2025-10-30
**Confidence:** 76%

---

## Architectural Patterns

### 1. MVC (Model-View-Controller) - Confidence: 85%

**Implementation:**
- **Models:** Data structures (src/models/)
- **Views:** API routes/endpoints (src/routes/)
- **Controllers:** Request handlers (src/controllers/)

**Example:**
```typescript
// Model: src/models/User.ts
export interface User {
  id: string;
  email: string;
  name: string;
}

// Controller: src/controllers/UserController.ts
export class UserController {
  async getUser(req: Request, res: Response) {
    const user = await userService.findById(req.params.id);
    res.json(user);
  }
}

// View/Route: src/routes/userRoutes.ts
router.get('/users/:id', userController.getUser);
```

**Evidence:** 23 controllers, 18 models, 15 route files

---

### 2. Repository Pattern - Confidence: 82%

**Purpose:** Abstract database access, enable testing

**Implementation:**
```typescript
// Repository: src/repositories/UserRepository.ts
export class UserRepository {
  async findById(id: string): Promise<User | null> {
    return prisma.user.findUnique({ where: { id } });
  }

  async create(data: CreateUserDto): Promise<User> {
    return prisma.user.create({ data });
  }
}

// Service uses repository
export class UserService {
  constructor(private userRepo: UserRepository) {}

  async getUser(id: string) {
    return this.userRepo.findById(id);
  }
}
```

**Evidence:** 12 repository classes found

---

### 3. Service Layer Pattern - Confidence: 88%

**Purpose:** Encapsulate business logic, keep controllers thin

**Implementation:**
```typescript
// Thin controller
export class UserController {
  async createUser(req: Request, res: Response) {
    const user = await userService.createUser(req.body);
    res.status(201).json(user);
  }
}

// Fat service (business logic)
export class UserService {
  async createUser(data: CreateUserDto): Promise<User> {
    // Validate email uniqueness
    const existing = await this.userRepo.findByEmail(data.email);
    if (existing) throw new AppError('Email exists', 400);

    // Hash password
    const passwordHash = await bcrypt.hash(data.password, 12);

    // Create user
    return this.userRepo.create({...data, passwordHash});
  }
}
```

**Evidence:** 28 service classes

---

### 4. Middleware Pattern - Confidence: 90%

**Purpose:** Request/response processing pipeline

**Common Middleware:**
1. **Authentication:** Verify JWT tokens
2. **Validation:** Validate request body with Zod
3. **Error Handling:** Catch and format errors
4. **Logging:** Log requests

**Example:**
```typescript
// Auth middleware
export const authMiddleware = async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) throw new AppError('Unauthorized', 401);

  const decoded = jwt.verify(token, JWT_SECRET);
  req.user = decoded;
  next();
};

// Usage
router.get('/profile', authMiddleware, profileController.get);
```

**Evidence:** 9 middleware functions

---

## Design Patterns

### 1. Singleton Pattern - Confidence: 90%

**Use Case:** Database connection, app configuration

**Implementation:**
```typescript
// src/database/connection.ts
class Database {
  private static instance: Database;
  private connection: PrismaClient;

  private constructor() {
    this.connection = new PrismaClient();
  }

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  getConnection() {
    return this.connection;
  }
}

export const db = Database.getInstance();
```

**Evidence:** 5 singleton instances

---

### 2. Factory Pattern - Confidence: 75%

**Use Case:** Object creation with complex setup

**Implementation:**
```typescript
// src/factories/UserFactory.ts
export class UserFactory {
  static create(role: UserRole): User {
    const baseUser = {
      id: uuid(),
      createdAt: new Date(),
    };

    if (role === 'ADMIN') {
      return {...baseUser, permissions: adminPermissions};
    }
    return {...baseUser, permissions: userPermissions};
  }
}
```

**Evidence:** 8 factory classes/functions

---

### 3. Dependency Injection - Confidence: 88%

**Use Case:** Loose coupling, testability

**Implementation:**
```typescript
// Constructor injection
export class UserController {
  constructor(
    private userService: UserService,
    private emailService: EmailService
  ) {}

  async createUser(req, res) {
    const user = await this.userService.create(req.body);
    await this.emailService.sendWelcome(user.email);
    res.json(user);
  }
}

// DI container (inferred usage)
const userRepository = new UserRepository(prisma);
const userService = new UserService(userRepository);
const userController = new UserController(userService, emailService);
```

**Evidence:** 45 classes use constructor injection

---

### 4. Observer Pattern - Confidence: 70%

**Use Case:** Event-driven architecture

**Implementation:**
```typescript
// Event emitter
import { EventEmitter } from 'events';

const orderEvents = new EventEmitter();

// Emit event
orderEvents.emit('order.created', order);

// Subscribe to event
orderEvents.on('order.created', async (order) => {
  await emailService.sendOrderConfirmation(order);
  await analyticsService.trackOrder(order);
});
```

**Evidence:** 3 event emitters detected

---

## Coding Conventions

### 1. Error Handling Convention

**Pattern:** Custom error classes with HTTP status codes

```typescript
class AppError extends Error {
  statusCode: number;
  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
  }
}

// Usage
if (!user) throw new AppError('User not found', 404);
if (user.role !== 'ADMIN') throw new AppError('Forbidden', 403);
```

---

### 2. Validation Convention

**Pattern:** Zod schemas + validation middleware

```typescript
// Define schema
const createUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(2),
});

// Validation middleware
const validateBody = (schema) => (req, res, next) => {
  const result = schema.safeParse(req.body);
  if (!result.success) {
    throw new AppError('Validation failed', 400);
  }
  next();
};

// Usage
router.post('/users', validateBody(createUserSchema), controller.create);
```

---

### 3. Async/Await Convention

**Pattern:** Consistent async/await, no callbacks

```typescript
// ‚úÖ Good (async/await)
async function getUser(id: string) {
  const user = await userRepo.findById(id);
  return user;
}

// ‚ùå Avoid (callbacks)
function getUser(id: string, callback) {
  userRepo.findById(id, (err, user) => {
    callback(err, user);
  });
}
```

**Consistency:** 98% (excellent)

---

### 4. Configuration Convention

**Pattern:** Environment variables + central config

```typescript
// src/config/app.ts
export const config = {
  port: process.env.PORT || 3000,
  databaseUrl: process.env.DATABASE_URL,
  jwtSecret: process.env.JWT_SECRET,
  nodeEnv: process.env.NODE_ENV || 'development',
};

// Usage
app.listen(config.port);
```

---

## Anti-Patterns Detected ‚ö†Ô∏è

### 1. God Objects (Low Severity)

**Issue:** Some service classes have too many responsibilities
**Example:** AuthService handles login, registration, password reset, email verification, token management (6+ responsibilities)
**Recommendation:** Split into smaller services (AuthService, TokenService, EmailVerificationService)

### 2. Low Test Coverage (High Severity)

**Issue:** Only 18% code coverage
**Impact:** High risk of bugs, difficult refactoring
**Recommendation:** Increase to 80%+ coverage

### 3. Inconsistent Error Handling (Medium Severity)

**Issue:** Some files use custom errors, others throw generic Error
**Impact:** Inconsistent API error responses
**Recommendation:** Enforce AppError usage via linting

---

## Recommended Patterns (Not Currently Used)

### 1. CQRS (Command Query Responsibility Segregation)

**Benefit:** Separate read/write operations for complex domains
**Use Case:** Order management (complex queries + state changes)

### 2. Event Sourcing

**Benefit:** Audit trail, replay events
**Use Case:** Order status changes, user actions

### 3. Circuit Breaker

**Benefit:** Fault tolerance for external services
**Use Case:** Payment processing, email sending

---

*Patterns detected from codebase analysis. Recommendations are sugges and require team discussion before adoption.*
```

---

## Complete JSON Output Formats

### Successful Documentation Generation

```json
{
  "documentation_files": {
    "architecture": ".claude/docs/architecture.md",
    "standards": ".claude/docs/standards.md",
    "patterns": ".claude/docs/patterns.md"
  },
  "confidence_score": 78,
  "review_checklist": ".claude/docs/review-checklist.md",
  "analysis_summary": {
    "files_analyzed": 487,
    "lines_analyzed": 48392,
    "patterns_identified": 12,
    "confidence_breakdown": {
      "architecture": 78,
      "standards": 82,
      "patterns": 76
    }
  },
  "telemetry": {
    "skill": "document-project",
    "project_name": "MyApp",
    "codebase_path": "src/",
    "duration_ms": 263000,
    "files_analyzed": 487,
    "lines_analyzed": 48392,
    "confidence_score": 78,
    "patterns_identified": 12
  }
}
```

### Partial Documentation (Low Confidence)

```json
{
  "documentation_files": {
    "architecture": ".claude/docs/architecture.md",
    "standards": ".claude/docs/standards.md",
    "patterns": ".claude/docs/patterns.md"
  },
  "confidence_score": 52,
  "review_checklist": ".claude/docs/review-checklist.md",
  "warning": "Confidence below 70% - extensive human review required",
  "low_confidence_areas": [
    "API specifications (45%)",
    "Database architecture (38%)",
    "Security implementation (52%)"
  ],
  "telemetry": {
    "skill": "document-project",
    "duration_ms": 298000,
    "confidence_score": 52
  }
}
```

---

## Review Checklist Template

```markdown
# Documentation Review Checklist

**Generated:** 2025-10-30
**Overall Confidence:** 78%

---

## ‚ö†Ô∏è High Priority Reviews (Confidence <70%)

### 1. API Request/Response Schemas (Confidence: 72%)
- [ ] Verify actual request body formats for each endpoint
- [ ] Document response schemas (success and error cases)
- [ ] Confirm HTTP status codes for each endpoint
- [ ] Document authentication requirements

**Why Low Confidence:** Schemas inferred from code, may not match actual usage

---

### 2. Database Schema (Confidence: 68%)
- [ ] Review Prisma schema file (prisma/schema.prisma)
- [ ] Verify table names and column types
- [ ] Confirm relationships (foreign keys)
- [ ] Verify indexes and constraints

**Why Low Confidence:** Schema inferred from models, not from actual database

---

### 3. Performance Architecture (Confidence: 45%)
- [ ] Document caching strategy (if any)
- [ ] Verify rate limiting implementation
- [ ] Review database query optimization
- [ ] Confirm load balancing/scaling approach

**Why Low Confidence:** No clear caching or optimization patterns detected

---

## Medium Priority Reviews (Confidence 70-80%)

### 4. Security Implementation (Confidence: 75%)
- [ ] Review JWT configuration (secret rotation, expiration)
- [ ] Verify HTTPS enforcement
- [ ] Confirm input sanitization completeness
- [ ] Review authentication middleware

### 5. Error Handling (Confidence: 78%)
- [ ] Standardize error responses across all endpoints
- [ ] Document error codes and messages
- [ ] Verify error logging

---

## Low Priority Reviews (Confidence >80%)

### 6. Technology Stack (Confidence: 98%)
- [ ] Verify all dependencies are current and documented
- [ ] Review for deprecated dependencies

### 7. Code Organization (Confidence: 92%)
- [ ] Confirm feature-based structure is intentional
- [ ] Document any deviations from standard structure

---

*After completing this review, update the documentation and increase confidence scores.*
```

---

## Error Templates

### Error: Codebase Too Large

```
‚ùå Error: Codebase too large for automated analysis

Files Found: 1,247,893
Lines of Code: 5,234,781

Maximum Supported: 500,000 lines
Your Project: 5,234,781 lines (10x over limit)

Recommendation:
1. Analyze a subset (e.g., src/core/)
2. Use manual documentation
3. Split into multiple projects

Cannot proceed with automated documentation.
```

### Error: No Clear Structure

```
‚ùå Error: No clear project structure detected

Issues Identified:
- No recognizable framework (Express, Django, Rails, etc.)
- No clear separation of concerns
- Mixed languages without pattern
- No package.json, requirements.txt, or similar manifest

Confidence: 12% (too low for useful documentation)

Recommendation:
- Organize codebase first
- Add package manifest
- Establish clear structure
- Then re-run documentation generator
```

---

*Complete templates and output formats for document-project skill*
